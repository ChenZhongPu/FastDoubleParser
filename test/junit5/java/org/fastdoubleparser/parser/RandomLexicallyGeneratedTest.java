/*
 * Copyright © 2021. Werner Randelshofer, Switzerland. MIT License.
 */

package org.fastdoubleparser.parser;

import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

class RandomLexicallyGeneratedTest {
    /**
     * The purpose of this test factory is to discover new cases, where
     * {@link FastDoubleParser#parseDouble(CharSequence)} does not
     * produce the same result like {@link Double#parseDouble(String)}.
     * <p>
     * Unfortunately, the space of input values is huge, it includes
     * all character sequences from lengths in the range
     * [0,{@value Integer#MAX_VALUE}].
     * <p>
     * Each run of this method produces new test cases with random
     * input generated by applying the syntax rules for a double
     * value.
     * <p>
     * <p>
     * References:
     * <dl>
     *     <dt>Java® Platform, Standard Edition & Java Development Kit.
     *          Version 16 API Specification.
     *     Javadoc of class java.lang.Double, method parseDouble(String).</dt>
     *     <dd><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Double.html#valueOf(java.lang.String)">
     *         docs.oracle.com</a></dd>
     * </dl>
     * <dl>
     *     <dt>The Java Language Specification. Java SE 16 Edition.
     *     Chapter 3.10.2 Floating-Point Literals</dt>
     *     <dd><a href="https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.10.2">
     *         docs.oracle.com</a></dd>
     * </dl>
     */
    @TestFactory
    Stream<DynamicTest> dynamicTestsRandomStringsOfIncreasingLengthWithWhitespace() {
                    Random rng = new Random();
        return IntStream.range(1, 1_000).mapToObj(i -> {
                    String str = produceRandomInputStringFromLexicalRuleWithWhitespace(i, rng);
                    return dynamicTest(i + ": " + str,
                            () -> testAgainstDoubleParseDouble(str));
                }
        );
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsRandomStringFrom1SyntaxRuleWithoutWhitespace() {
                    Random rng = new Random(0);
        return IntStream.range(1, 100_000).mapToObj(i -> {
                    String str = produceRandomInputStringFromLexicalRuleWithoutWhitespace(1, rng);
                    return dynamicTest(i + ": " + str,
                            () -> testAgainstDoubleParseDouble(str));
                }
        );
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsRandomStringFrom10SyntaxRuleWithoutWhitespace() {
                    Random rng = new Random(0);
        return IntStream.range(1, 100_000).mapToObj(i -> {
                    String str = produceRandomInputStringFromLexicalRuleWithoutWhitespace(10, rng);
                    return dynamicTest(i + ": " + str,
                            () -> testAgainstDoubleParseDouble(str));
                }
        );
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsRandomStringFrom40SyntaxRuleWithoutWhitespace() {
        return IntStream.range(1, 100_000).mapToObj(i -> {
                    Random rng = new Random(i);
                    String str = produceRandomInputStringFromLexicalRuleWithoutWhitespace(40, rng);
                    return dynamicTest(i + ": " + str,
                            () -> testAgainstDoubleParseDouble(str));
                }
        );
    }

    /**
     * Produces a random input string from lexical rules.
     *
     * @param remaining the remaining number of rules to perform
     * @param rng       a random number generator
     * @return a string
     */
    private String produceRandomInputStringFromLexicalRuleWithWhitespace(int remaining, Random rng) {
        StringBuilder buf = new StringBuilder();
        remaining = produceRandomWhitespaces(remaining, rng, buf);
        switch (rng.nextInt(4)) {
        case 0:
            remaining = produceRandomSign(remaining, rng, buf);
            remaining = produceRandomNaNOrInfinity(remaining, rng, buf);
            break;
        case 1:
            remaining = produceRandomSign(remaining, rng, buf);
            remaining = produceRandomDecimalFloatingPointLiteral(remaining, rng, buf);
            break;
        case 2:
            remaining = produceRandomSign(remaining, rng, buf);
            remaining = produceRandomHexFloatingPointLiteral(remaining, rng, buf);
            break;
        case 3:
            remaining = produceRandomSignedInteger(remaining, rng, buf);
            break;
        }
        remaining = produceRandomWhitespaces(remaining, rng, buf);
        return buf.toString();
    }

    /**
     * Produces a random input string from lexical rules.
     * <dl>
     * <dt><i>FloatValue:</i>
     * <dd><i>[Sign]</i> {@code NaN}
     * <dd><i>[Sign]</i> {@code Infinity}
     * <dd><i>[Sign] FloatingPointLiteral</i>
     * <dd><i>[Sign] HexadecimalFloatingPointLiteral</i>
     * <dd><i>SignedInteger</i>
     * </dl>
     *
     * @param remaining the remaining number of rules to perform
     * @param rng       a random number generator
     * @return a string
     */
    private String produceRandomInputStringFromLexicalRuleWithoutWhitespace(int remaining, Random rng) {
        StringBuilder buf = new StringBuilder();
        switch (rng.nextInt(4)) {
        case 0:
            if (rng.nextBoolean()) {
                remaining = produceRandomSign(remaining, rng, buf);
            }
            remaining = produceRandomNaNOrInfinity(remaining, rng, buf);
            break;
        case 1:
            if (rng.nextBoolean()) {
                remaining = produceRandomSign(remaining, rng, buf);
            }
            remaining = produceRandomDecimalFloatingPointLiteral(remaining, rng, buf);
            break;
        case 2:
            if (rng.nextBoolean()) {
                remaining = produceRandomSign(remaining, rng, buf);
            }
            remaining = produceRandomHexFloatingPointLiteral(remaining, rng, buf);
            break;
        case 3:
            remaining = produceRandomSignedInteger(remaining, rng, buf);
            break;
        }
        return buf.toString();
    }

    private int produceRandomNaNOrInfinity(int remaining, Random rng, StringBuilder buf) {
        buf.append(rng.nextBoolean() ? "NaN" : "Infinity");
        remaining--;
        return remaining;

    }

    private int produceRandomSign(int remaining, Random rng, StringBuilder buf) {
        buf.append(rng.nextBoolean() ? '+' : '-');
        remaining--;
        return --remaining;
    }

    private int produceRandomDigit(int remaining, Random rng, StringBuilder buf) {
        buf.append(rng.nextInt(10));
        remaining--;
        return remaining;
    }

    /**
     * <dl>
     * <dt><i>DigitsAndUnderscores:</i>
     * <dd><i>DigitOrUnderscore {DigitOrUnderscore}</i>
     * <dd><i>Digit [DigitsAndUnderscores] Digit</i>
     * </dl>
     */
    private int produceRandomDigitsAndUnderscores(int remaining, Random rng, StringBuilder buf) {
        switch (rng.nextInt(2)) {
        case 0:
            remaining = produceRandomDigitOrUnderscore(remaining, rng, buf);
            int todo = rng.nextInt(Math.max(remaining, 1));
            for (int i = 0; i < todo; i++) {
                remaining = produceRandomDigitOrUnderscore(remaining, rng, buf);
            }
            break;
        case 1:
            remaining = produceRandomDigit(remaining, rng, buf);
            if (rng.nextBoolean()) {
                remaining = produceRandomDigitsAndUnderscores(remaining, rng, buf);
            }
            remaining = produceRandomDigit(remaining, rng, buf);
            break;
        }
        return remaining;
    }

    /**
     * <dl>
     * <dt><i>DecimalFloatingPointLiteral:</i>
     * <dd><i>Digits {@code .} [Digits] [ExponentPart] [FloatTypeSuffix]</i>
     * <dd><i>{@code .} Digits [ExponentPart] [FloatTypeSuffix]</i>
     * <dd><i>Digits ExponentPart [FloatTypeSuffix]</i>
     * <dd><i>Digits [ExponentPart] FloatTypeSuffix</i>
     * </dl>
     */
    private int produceRandomDecimalFloatingPointLiteral(int remaining, Random rng, StringBuilder buf) {
        switch (rng.nextInt(4)) {
        case 0:
            remaining = produceRandomDigits(remaining, rng, buf);
            buf.append('.');
            remaining--;
            if (rng.nextBoolean()) {
                remaining = produceRandomDigits(remaining, rng, buf);
            }
            if (rng.nextBoolean()) {
                remaining = produceRandomExponentPart(remaining, rng, buf);
            }
            if (rng.nextBoolean()) {
                remaining = produceRandomFloatTypeSuffix(remaining, rng, buf);
            }
            break;
        case 1:
            buf.append('.');
            remaining--;
            remaining = produceRandomDigits(remaining, rng, buf);
            if (rng.nextBoolean()) {
                remaining = produceRandomExponentPart(remaining, rng, buf);
            }
            if (rng.nextBoolean()) {
                remaining = produceRandomFloatTypeSuffix(remaining, rng, buf);
            }
            break;
        case 2:
            remaining = produceRandomDigits(remaining, rng, buf);
            remaining = produceRandomExponentPart(remaining, rng, buf);
            if (rng.nextBoolean()) {
                remaining = produceRandomFloatTypeSuffix(remaining, rng, buf);
            }
            break;
        case 3:
            remaining = produceRandomDigits(remaining, rng, buf);
            if (rng.nextBoolean()) {
                remaining = produceRandomExponentPart(remaining, rng, buf);
            }
            remaining = produceRandomFloatTypeSuffix(remaining, rng, buf);
            break;
        }
        return remaining;
    }

    private int produceRandomHexFloatingPointLiteral(int remaining, Random rng, StringBuilder buf) {
        remaining = produceRandomHexSignificand(remaining, rng, buf);
        remaining = produceRandomBinaryExponent(remaining, rng, buf);
        remaining = produceRandomFloatTypeSuffix(remaining, rng, buf);
        return remaining;
    }

    /**
     * <dl>
     * <dt><i>HexSignificand:</i>
     * <dd><i>HexNumeral</i>
     * <dd><i>HexNumeral</i> {@code .}
     * <dd>{@code 0x} <i>[HexDigits]</i> {@code .} <i>HexDigits</i>
     * <dd>{@code 0X} <i>[HexDigits]</i> {@code .} <i>HexDigits</i>
     * </dl>
     */
    private int produceRandomHexSignificand(int remaining, Random rng, StringBuilder buf) {
        switch (rng.nextInt(3)) {
        case 0:
            remaining = produceRandomHexNumeral(remaining, rng, buf);
            break;
        case 1:
            remaining = produceRandomHexNumeral(remaining, rng, buf);
            buf.append('.');
            remaining--;
            break;
        case 2:
            buf.append(rng.nextBoolean() ? "0x" : "0X");
            remaining--;
            if (rng.nextBoolean()) {
                remaining = produceRandomHexDigits(remaining, rng, buf);
            }
            buf.append('.');
            remaining--;
            remaining = produceRandomHexDigits(remaining, rng, buf);
            break;
        }
        return remaining;
    }

    private int produceRandomHexNumeral(int remaining, Random rng, StringBuilder buf) {
        buf.append(rng.nextBoolean() ? "0x" : "0X");
        remaining--;
        remaining = produceRandomHexDigits(remaining, rng, buf);
        return remaining;
    }

    private int produceRandomHexDigits(int remaining, Random rng, StringBuilder buf) {
        remaining = produceRandomHexDigit(remaining, rng, buf);
        if (rng.nextBoolean()) {
            remaining = produceRandomHexDigitsAndUnderscores(remaining, rng, buf);
            remaining = produceRandomHexDigit(remaining, rng, buf);
        }
        return remaining;
    }

    private final static char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f',
            'A', 'B', 'C', 'D', 'E', 'F',
    };
    /**
     * Underscore is omitted here, because {@link Double#valueOf(String)} does
     * not permit them.
     */
    private final static char[] HEX_DIGITS_OR_UNDERSCORE = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f',
            'A', 'B', 'C', 'D', 'E', 'F' //, '_'
    };

    private int produceRandomHexDigit(int remaining, Random rng, StringBuilder buf) {
        buf.append(HEX_DIGITS[rng.nextInt(HEX_DIGITS.length)]);
        remaining--;
        return remaining;
    }

    private int produceRandomHexDigitOrUnderscore(int remaining, Random rng, StringBuilder buf) {
        buf.append(HEX_DIGITS_OR_UNDERSCORE[rng.nextInt(HEX_DIGITS_OR_UNDERSCORE.length)]);
        remaining--;
        return remaining;
    }

    /**
     * Underscore is omitted here, because {@link Double#valueOf(String)} does
     * not permit them.
     */
    private int produceRandomDigitOrUnderscore(int remaining, Random rng, StringBuilder buf) {
        return produceRandomDigit(remaining, rng, buf);
    }

    /**
     * <dl>
     * <dt><i>Digits:</i>
     * <dd><i>Digit</i>
     * <dd><i>Digit [DigitsAndUnderscores] Digit</i>
     * </dl>
     */
    private int produceRandomDigits(int remaining, Random rng, StringBuilder buf) {
        switch (rng.nextInt(2)) {
        case 0:
            remaining = produceRandomDigit(remaining, rng, buf);
            break;
        case 1:
            remaining = produceRandomDigit(remaining, rng, buf);
            if (rng.nextBoolean()) {
                remaining = produceRandomDigitsAndUnderscores(remaining, rng, buf);
            }
            remaining = produceRandomDigit(remaining, rng, buf);
            break;
        }

        return remaining;
    }

    /**
     * <dl>
     * <dt><i>ExponentPart:</i>
     * <dd><i>ExponentIndicator SignedInteger</i>
     * </dl>
     */
    private int produceRandomExponentPart(int remaining, Random rng, StringBuilder buf) {
                buf.append(rng.nextBoolean() ? 'e' : 'E');
                remaining--;
            remaining = produceRandomSignedInteger(remaining, rng, buf);
        return remaining;
    }

    /**
     * <dl>
     * <dt><i>BinaryExponent:</i>
     * <dd><i>BinaryExponentIndicator SignedInteger</i>
     * </dl>
     *
     * <dl>
     * <dt><i>BinaryExponentIndicator:</i>
     * <dd>{@code p}
     * <dd>{@code P}
     * </dl>
     */
    private int produceRandomBinaryExponent(int remaining, Random rng, StringBuilder buf) {
        buf.append(rng.nextBoolean() ? 'p' : 'P');
        remaining--;
        remaining = produceRandomSignedInteger(remaining, rng, buf);
        return remaining;
    }

    /**
     * This method produces nothing because
     * FloatTypeSuffix is not accepted by {@link Double#parseDouble(String)}.
     *
     * <dl>
     * <dt><i>FloatTypeSuffix:</i>
     * <dd><i>(one of)</i>
     * <dd><i>f F d D</i>
     * </dl>
     */
    private int produceRandomFloatTypeSuffix(int remaining, Random rng, StringBuilder buf) {
        /*
        switch(rng.nextInt(4)) {
        case 0:buf.append('f');break;
        case 1:buf.append('F');break;
        case 2:buf.append('d');break;
        case 3:buf.append('D');break;
        }
        remaining--;
         */
        return remaining;
    }

    /**
     * <dl>
     * <dt><i>SignedInteger:</i>
     * <dd><i>[Sign] Digits</i>
     * </dl>
     */
    private int produceRandomSignedInteger(int remaining, Random rng, StringBuilder buf) {
        if (rng.nextBoolean()) {
            remaining = produceRandomSign(remaining, rng, buf);
        }
        remaining = produceRandomDigits(remaining, rng, buf);
        return remaining;
    }

    private int produceRandomWhitespaces(int remaining, Random rng, StringBuilder buf) {
        if (remaining > 0) {
            int todo = rng.nextInt(remaining + 1);
            for (int i = 0; i < todo; i++) {
                buf.append((char) rng.nextInt(0x21));
            }
            remaining -= todo;
        }
        return remaining;
    }

    private int produceRandomHexDigitsAndUnderscores(int remaining, Random rng, StringBuilder buf) {
        int todo = rng.nextInt(Math.max(remaining, 1));
        for (int i = 0; i < todo; i++) {
            remaining = produceRandomHexDigitOrUnderscore(remaining, rng, buf);
        }
        return remaining;
    }

    /**
     * Given an input String {@code str},
     * tests if {@link FastDoubleParser#parseDouble(CharSequence)}
     * produces the same result like {@link Double#parseDouble(String)}.
     *
     * @param str the given input string
     */
    private void testAgainstDoubleParseDouble(String str) {
        double expected = Double.parseDouble(str);
        double actual = FastDoubleParser.parseDouble(str);
        assertEquals(expected, actual, str);
    }

}